###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.40.0.51500/W32 for ARM     10/Jun/2011  09:53:52 #
# Copyright (C) 1999-2009 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  L:\USB_AUDIO_JII\at91lib\usb\device\core\USBD_OTGHS.c    #
#    Command line =  L:\USB_AUDIO_JII\at91lib\usb\device\core\USBD_OTGHS.c    #
#                    -D at91sam7s256 -D flash -D TRACE_LEVEL=3 -lC            #
#                    L:\USB_AUDIO_JII\at91sam7s-ek\ewp\at91sam7s256_flash\Lis #
#                    t\ --remarks --diag_suppress Pe826,Pe1375 -o             #
#                    L:\USB_AUDIO_JII\at91sam7s-ek\ewp\at91sam7s256_flash\Obj #
#                    \ --debug --endian=little --cpu=ARM7TDMI -e --fpu=None   #
#                    --dlib_config "D:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4ARM\arm\INC\DLib_Config_Full.h" -I          #
#                    L:\USB_AUDIO_JII\at91sam7s-ek\ewp\..\..\at91lib/peripher #
#                    als\ -I L:\USB_AUDIO_JII\at91sam7s-ek\ewp\..\..\at91lib/ #
#                    components\ -I L:\USB_AUDIO_JII\at91sam7s-ek\ewp\..\..\a #
#                    t91lib/usb/device\ -I L:\USB_AUDIO_JII\at91sam7s-ek\ewp\ #
#                    ..\..\at91lib\ -I L:\USB_AUDIO_JII\at91sam7s-ek\ewp\..\. #
#                    .\at91lib/boards/at91sam7s-ek\ -I                        #
#                    L:\USB_AUDIO_JII\at91sam7s-ek\ewp\..\..\app\ -I          #
#                    "D:\Program Files\IAR Systems\Embedded Workbench         #
#                    5.4ARM\arm\INC\" --interwork --cpu_mode arm -Oh          #
#    List file    =  L:\USB_AUDIO_JII\at91sam7s-ek\ewp\at91sam7s256_flash\Lis #
#                    t\USBD_OTGHS.lst                                         #
#    Object file  =  L:\USB_AUDIO_JII\at91sam7s-ek\ewp\at91sam7s256_flash\Obj #
#                    \USBD_OTGHS.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

L:\USB_AUDIO_JII\at91lib\usb\device\core\USBD_OTGHS.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*!
     31              Functions for OTGHS peripheral usage.
     32          */
     33           
     34          //------------------------------------------------------------------------------
     35          //      Headers
     36          //------------------------------------------------------------------------------
     37          
     38          #include <board.h>
     39          
     40          #ifdef CHIP_OTGHS
     41          
     42          #include "common.h"
     43          #include "trace.h"
     44          #include "usb.h"
     45          
     46          //------------------------------------------------------------------------------
     47          //         Definitions
     48          //------------------------------------------------------------------------------
     49          
     50          #define NUM_IT_MAX       (AT91C_BASE_OTGHS->OTGHS_IPFEATURES & AT91C_OTGHS_EPT_NBR_MAX)
     51          #define NUM_IT_MAX_DMA   ((AT91C_BASE_OTGHS->OTGHS_IPFEATURES & AT91C_OTGHS_DMA_CHANNEL_NBR)>>4)
     52          
     53          #define SHIFT_DMA         24
     54          #define SHIFT_INTERUPT    12
     55          
     56          #define DMA
     57          
     58          //------------------------------------------------------------------------------
     59          //      Structures
     60          //------------------------------------------------------------------------------
     61          
     62          // \brief  Endpoint states
     63          typedef enum {
     64          
     65              endpointStateDisabled,
     66              endpointStateIdle,
     67              endpointStateWrite,
     68              endpointStateRead,
     69              endpointStateHalted
     70          
     71          } EndpointState_t;
     72          
     73          //------------------------------------------------------------------------------
     74          //      Macros
     75          //------------------------------------------------------------------------------
     76          
     77          //------------------------------------------------------------------------------
     78          //      Internal Functions
     79          //------------------------------------------------------------------------------
     80          //------------------------------------------------------------------------------
     81          // \brief  Returns a pointer to the OTGHS controller interface used by an USB
     82          //         driver
     83          //
     84          //         The pointer is cast to the correct type (AT91PS_OTGHS).
     85          // \param  pUsb Pointer to a S_usb instance
     86          // \return Pointer to the USB controller interface
     87          // \see    S_usb
     88          //------------------------------------------------------------------------------
     89          static AT91PS_OTGHS OTGHS_GetDriverInterface(const S_usb *pUsb)
     90          {
     91              return (AT91PS_OTGHS) pUsb->pDriver->pInterface;
     92          }
     93          
     94          //------------------------------------------------------------------------------
     95          // \fn      OTGHS_GetInterfaceEPT
     96          // \brief   Returns OTGHS endpoint FIFO interface from S_usb structure
     97          //------------------------------------------------------------------------------
     98          static AT91PS_OTGHS_EPTFIFO OTGHS_GetInterfaceEPT(const S_usb *pUsb) 
     99          {
    100              return (AT91PS_OTGHS_EPTFIFO) pUsb->pDriver->pEndpointFIFO;
    101          }
    102          
    103          
    104          //------------------------------------------------------------------------------
    105          // \brief  Enables the peripheral clock of the USB controller associated with
    106          //         the specified USB driver
    107          // \param  pUsb Pointer to a S_usb instance
    108          // \see    S_usb
    109          //------------------------------------------------------------------------------
    110          static void OTGHS_EnableMCK(const S_usb *pUsb)
    111          {
    112          
    113          }
    114          
    115          //------------------------------------------------------------------------------
    116          // \brief  Disables the peripheral clock of the USB controller associated with
    117          //         the specified USB driver
    118          // \param  pUsb Pointer to a S_usb instance
    119          // \see    S_usb
    120          //------------------------------------------------------------------------------
    121          static void OTGHS_DisableMCK(const S_usb *pUsb)
    122          {
    123          
    124          }
    125          
    126          //------------------------------------------------------------------------------
    127          // \brief  Enables the 48MHz clock of the USB controller associated with
    128          //         the specified USB driver
    129          // \param  pUsb Pointer to a S_usb instance
    130          // \see    S_usb
    131          //------------------------------------------------------------------------------
    132          static void OTGHS_EnableOTGHSCK(const S_usb *pUsb)
    133          {
    134          
    135          }
    136          
    137          //------------------------------------------------------------------------------
    138          // \brief  Disables the 48MHz clock of the USB controller associated with
    139          //         the specified USB driver
    140          // \param  pUsb Pointer to a S_usb instance
    141          // \see    S_usb
    142          //------------------------------------------------------------------------------
    143          static void OTGHS_DisableOTGHSCK(const S_usb *pUsb)
    144          {
    145          
    146          }
    147          
    148          //------------------------------------------------------------------------------
    149          // \brief  Enables the transceiver of the USB controller associated with
    150          //         the specified USB driver
    151          // \param  pUsb Pointer to a S_usb instance
    152          // \see    S_usb
    153          //------------------------------------------------------------------------------
    154          static void OTGHS_EnableTransceiver(const S_usb *pUsb)
    155          {
    156              SET(OTGHS_GetDriverInterface(pUsb)->OTGHS_CTRL, AT91C_OTGHS_OTGPADE);
    157          }
    158          
    159          //------------------------------------------------------------------------------
    160          // \brief  Disables the transceiver of the USB controller associated with
    161          //         the specified USB driver
    162          // \param  pUsb Pointer to a S_usb instance
    163          // \see    S_usb
    164          //------------------------------------------------------------------------------
    165          static void OTGHS_DisableTransceiver(const S_usb *pUsb)
    166          {
    167              CLEAR(OTGHS_GetDriverInterface(pUsb)->OTGHS_CTRL, AT91C_OTGHS_OTGPADE);
    168          }
    169          
    170          //------------------------------------------------------------------------------
    171          // \brief  Invokes the callback associated with a finished transfer on an
    172          //         endpoint
    173          // \param  pEndpoint Pointer to a S_usb_endpoint instance
    174          // \param  bStatus   Status code returned by the transfer operation
    175          // \see    Status codes
    176          // \see    S_usb_endpoint
    177          //------------------------------------------------------------------------------
    178          static void OTGHS_EndOfTransfer(S_usb_endpoint *pEndpoint,
    179                                                   char bStatus)
    180          {
    181              if ((pEndpoint->dState == endpointStateWrite)
    182                  || (pEndpoint->dState == endpointStateRead)) {
    183          
    184                  TRACE_DEBUG_L("E");
    185          
    186                  // Endpoint returns in Idle state
    187                  pEndpoint->dState = endpointStateIdle;
    188          
    189                  // Invoke callback is present
    190                  if (pEndpoint->fCallback != 0) {
    191          
    192                      pEndpoint->fCallback((unsigned int) pEndpoint->pArgument,
    193                                           (unsigned int) bStatus,
    194                                           pEndpoint->dBytesTransferred,
    195                                           pEndpoint->dBytesRemaining
    196                                           + pEndpoint->dBytesBuffered);
    197                  }
    198              }
    199          }
    200          
    201          //------------------------------------------------------------------------------
    202          // \brief  Transfers a data payload from the current tranfer buffer to the
    203          //         endpoint FIFO.
    204          // \param  pUsb      Pointer to a S_usb instance
    205          // \param  bEndpoint Index of endpoint
    206          // \return Number of bytes transferred
    207          // \see    S_usb
    208          //------------------------------------------------------------------------------
    209          static unsigned int OTGHS_WritePayload(const S_usb *pUsb,
    210                                                 unsigned char bEndpoint)
    211          {
    212              AT91PS_OTGHS_EPTFIFO pInterfaceEPT = OTGHS_GetInterfaceEPT(pUsb);
    213              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
    214              char           *pfifo;
    215              unsigned int   dBytes;
    216              unsigned int   dCtr;
    217          
    218              pfifo = (char*)&(pInterfaceEPT->OTGHS_READEPT0[bEndpoint*16384]);
    219          
    220              // Get the number of bytes to send
    221              dBytes = min(pEndpoint->wMaxPacketSize, pEndpoint->dBytesRemaining);
    222          
    223              // Transfer one packet in the FIFO buffer
    224              for (dCtr = 0; dCtr < dBytes; dCtr++) {
    225          
    226                  pfifo[dCtr] = *(pEndpoint->pData);
    227                  pEndpoint->pData++;
    228              }
    229          
    230              pEndpoint->dBytesBuffered += dBytes;
    231              pEndpoint->dBytesRemaining -= dBytes;
    232          
    233              return dBytes;
    234          }
    235          
    236          //----------------------------------------------------------------------------
    237          // \brief  Transfers a data payload from an endpoint FIFO to the current
    238          //         transfer buffer.
    239          // \param  pUsb        Pointer to a S_usb instance
    240          // \param  bEndpoint   Index of endpoint
    241          // \param  wPacketSize Size of received data packet
    242          // \return Number of bytes transferred
    243          // \see    S_usb
    244          //------------------------------------------------------------------------------
    245          static unsigned int OTGHS_GetPayload(const S_usb    *pUsb,
    246                                               unsigned char  bEndpoint,
    247                                               unsigned short wPacketSize)
    248          {
    249              AT91PS_OTGHS_EPTFIFO pInterfaceEPT = OTGHS_GetInterfaceEPT(pUsb);
    250              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
    251              char           *pfifo;
    252              unsigned int   dBytes;
    253              unsigned int   dCtr;
    254          
    255              pfifo = (char*)&(pInterfaceEPT->OTGHS_READEPT0[bEndpoint*16384]);
    256          
    257              // Get number of bytes to retrieve
    258              dBytes = min(pEndpoint->dBytesRemaining, wPacketSize);
    259          
    260              // Retrieve packet
    261              for (dCtr = 0; dCtr < dBytes; dCtr++) {
    262          
    263                  *(pEndpoint->pData) = pfifo[dCtr];
    264                  pEndpoint->pData++;
    265              }
    266          
    267              pEndpoint->dBytesRemaining -= dBytes;
    268              pEndpoint->dBytesTransferred += dBytes;
    269              pEndpoint->dBytesBuffered += wPacketSize - dBytes;
    270          
    271              return dBytes;
    272          }
    273          
    274          //------------------------------------------------------------------------------
    275          // \brief  Transfers a received SETUP packet from endpoint 0 FIFO to the
    276          //         S_usb_request structure of an USB driver
    277          // \param  pUsb Pointer to a S_usb instance
    278          // \see    S_usb
    279          //------------------------------------------------------------------------------
    280          static void OTGHS_GetSetup(const S_usb *pUsb)
    281          {
    282              unsigned int *pData = (unsigned int *) USB_GetSetup(pUsb);
    283              AT91PS_OTGHS_EPTFIFO pInterfaceEPT = OTGHS_GetInterfaceEPT(pUsb);
    284          
    285              pData[0] = pInterfaceEPT->OTGHS_READEPT0[0];
    286              pData[1] = pInterfaceEPT->OTGHS_READEPT0[0];
    287          }
    288          
    289          //------------------------------------------------------------------------------
    290          // \brief  This function reset all endpoint transfer descriptors
    291          // \param  pUsb Pointer to a S_usb instance
    292          // \see    S_usb
    293          //------------------------------------------------------------------------------
    294          static void OTGHS_ResetEndpoints(const S_usb *pUsb)
    295          {
    296              S_usb_endpoint *pEndpoint;
    297              unsigned char  bEndpoint;
    298          
    299              // Reset the transfer descriptor of every endpoint
    300              for (bEndpoint = 0; bEndpoint < pUsb->dNumEndpoints; bEndpoint++) {
    301          
    302                  pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
    303          
    304                  // Reset endpoint transfer descriptor
    305                  pEndpoint->pData = 0;
    306                  pEndpoint->dBytesRemaining = 0;
    307                  pEndpoint->dBytesTransferred = 0;
    308                  pEndpoint->dBytesBuffered = 0;
    309                  pEndpoint->fCallback = 0;
    310                  pEndpoint->pArgument = 0;
    311          
    312                  // Configure endpoint characteristics
    313                  pEndpoint->dState = endpointStateDisabled;
    314              }
    315          }
    316          
    317          //------------------------------------------------------------------------------
    318          // \brief  Disable all endpoints (except control endpoint 0), aborting current
    319          //         transfers if necessary.
    320          // \param  pUsb Pointer to a S_usb instance
    321          //------------------------------------------------------------------------------
    322          static void OTGHS_DisableEndpoints(const S_usb *pUsb)
    323          {
    324              S_usb_endpoint *pEndpoint;
    325              unsigned char  bEndpoint;
    326          
    327              // Foreach endpoint, if it is enabled, disable it and invoke the callback
    328              // Control endpoint 0 is not disabled
    329              for (bEndpoint = 1; bEndpoint < pUsb->dNumEndpoints; bEndpoint++) {
    330          
    331                  pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
    332                  OTGHS_EndOfTransfer(pEndpoint, USB_STATUS_RESET);
    333          
    334                  pEndpoint->dState = endpointStateDisabled;
    335              }
    336          }
    337          
    338          //------------------------------------------------------------------------------
    339          // \brief  Endpoint interrupt handler.
    340          //
    341          //         Handle IN/OUT transfers, received SETUP packets and STALLing
    342          // \param  pUsb      Pointer to a S_usb instance
    343          // \param  bEndpoint Index of endpoint
    344          // \see    S_usb
    345          //------------------------------------------------------------------------------
    346          static void OTGHS_EndpointHandler(const S_usb *pUsb, unsigned char bEndpoint)
    347          {
    348              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
    349              AT91PS_OTGHS pInterface = OTGHS_GetDriverInterface(pUsb);
    350              unsigned int dStatus = pInterface->OTGHS_DEVEPTCSR[bEndpoint];
    351              unsigned short wPacketSize;
    352          
    353              TRACE_DEBUG_L("Ept%d, 0x%X ", bEndpoint, dStatus);
    354          
    355              // Handle interrupts
    356              // IN packet sent
    357              if((ISSET(pInterface->OTGHS_DEVEPTCMR[bEndpoint], AT91C_OTGHS_TXINI))
    358              && (ISSET(dStatus, AT91C_OTGHS_TXINI ))) {
    359          
    360                  TRACE_DEBUG_L("Wr ");
    361          
    362                  if (pEndpoint->dBytesBuffered > 0) {
    363          
    364                      TRACE_DEBUG_L("%d ", pEndpoint->dBytesBuffered);
    365          
    366                      pEndpoint->dBytesTransferred += pEndpoint->dBytesBuffered;
    367                      pEndpoint->dBytesBuffered = 0;
    368                  }
    369          
    370                  if ((!pEndpoint->isDataSent) || (pEndpoint->dBytesRemaining > 0)) {
    371                      
    372                      OTGHS_WritePayload(pUsb, bEndpoint);
    373                      pEndpoint->isDataSent = true;
    374          
    375                      pInterface->OTGHS_DEVEPTCCR[bEndpoint] = AT91C_OTGHS_TXINI;
    376                      // For a non-control endpoint, the FIFOCON bit must be cleared
    377                      // to start the transfer
    378                      if ((AT91C_OTGHS_EPT_TYPE & pInterface->OTGHS_DEVEPTCFG[bEndpoint])
    379                          != AT91C_OTGHS_EPT_TYPE_CTL_EPT) {
    380          
    381                          pInterface->OTGHS_DEVEPTCDR[bEndpoint] = AT91C_OTGHS_FIFOCON;
    382                      }
    383                  }
    384                  else {
    385                      
    386                      pInterface->OTGHS_DEVEPTCDR[bEndpoint] = AT91C_OTGHS_TXINI;
    387          
    388                      // Disable interrupt if this is not a control endpoint
    389                      if ((AT91C_OTGHS_EPT_TYPE & pInterface->OTGHS_DEVEPTCFG[bEndpoint])
    390                          != AT91C_OTGHS_EPT_TYPE_CTL_EPT) {
    391          
    392                          pInterface->OTGHS_DEVIDR = 1<<SHIFT_INTERUPT<<bEndpoint;
    393          
    394                      }
    395                      OTGHS_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
    396                  }
    397              }
    398          
    399              // OUT packet received
    400              if(ISSET(dStatus, AT91C_OTGHS_RXOUT)) {
    401          
    402                  TRACE_DEBUG_L("Rd ");
    403          
    404                  // Check that the endpoint is in Read state
    405                  if (pEndpoint->dState != endpointStateRead) {
    406          
    407                      // Endpoint is NOT in Read state
    408                      if (ISCLEARED(pInterface->OTGHS_DEVEPTCFG[bEndpoint], AT91C_OTGHS_EPT_TYPE)
    409                       && ISCLEARED(dStatus, (0x7FF<<20))) {  // byte count
    410          
    411                          // Control endpoint, 0 bytes received
    412                          // Acknowledge the data and finish the current transfer
    413                          TRACE_DEBUG_L("Ack ");
    414                          pInterface->OTGHS_DEVEPTCCR[bEndpoint] = AT91C_OTGHS_RXOUT;
    415          
    416                          OTGHS_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
    417                      }
    418                      else if (ISSET(dStatus, AT91C_OTGHS_STALL)) {
    419          
    420                          // Non-control endpoint
    421                          // Discard stalled data
    422                          TRACE_DEBUG_L("Disc ");
    423                          pInterface->OTGHS_DEVEPTCCR[bEndpoint] = AT91C_OTGHS_RXOUT;
    424                      }
    425                      else {
    426          
    427                          // Non-control endpoint
    428                          // Nak data
    429                          TRACE_DEBUG_L("Nak ");
    430                          pInterface->OTGHS_DEVIDR = 1<<SHIFT_INTERUPT<<bEndpoint;
    431                      }
    432                  }
    433                  else {
    434          
    435                      // Endpoint is in Read state
    436                      // Retrieve data and store it into the current transfer buffer
    437                      wPacketSize = (unsigned short) ((dStatus >> 20) & 0x7FF);
    438          
    439                      TRACE_DEBUG_L("%d ", wPacketSize);
    440          
    441                      OTGHS_GetPayload(pUsb, bEndpoint, wPacketSize);
    442          
    443                      pInterface->OTGHS_DEVEPTCCR[bEndpoint] = AT91C_OTGHS_RXOUT;
    444                      pInterface->OTGHS_DEVEPTCDR[bEndpoint] = AT91C_OTGHS_FIFOCON;
    445          
    446                      if ((pEndpoint->dBytesRemaining == 0)
    447                          || (wPacketSize < pEndpoint->wMaxPacketSize)) {
    448          
    449                          pInterface->OTGHS_DEVEPTCDR[bEndpoint] = AT91C_OTGHS_RXOUT;
    450          
    451                          // Disable interrupt if this is not a control endpoint
    452                          if ((AT91C_OTGHS_EPT_TYPE & pInterface->OTGHS_DEVEPTCFG[bEndpoint])
    453                              != AT91C_OTGHS_EPT_TYPE_CTL_EPT) {
    454          
    455                              pInterface->OTGHS_DEVIDR = 1<<SHIFT_INTERUPT<<bEndpoint;
    456                          }
    457          
    458                          OTGHS_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
    459                      }
    460                  }
    461              }
    462          
    463              // SETUP packet received
    464              if(ISSET(dStatus, AT91C_OTGHS_RXSTP)) {
    465          
    466                  TRACE_DEBUG_L("Stp ");
    467          
    468                  // If a transfer was pending, complete it
    469                  // Handle the case where during the status phase of a control write
    470                  // transfer, the host receives the device ZLP and ack it, but the ack
    471                  // is not received by the device
    472                  if ((pEndpoint->dState == endpointStateWrite)
    473                      || (pEndpoint->dState == endpointStateRead)) {
    474          
    475                      OTGHS_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
    476                  }
    477          
    478                  // Copy the setup packet in S_usb
    479                  OTGHS_GetSetup(pUsb);
    480          
    481                  // Acknowledge setup packet
    482                  pInterface->OTGHS_DEVEPTCCR[bEndpoint] = AT91C_OTGHS_RXSTP;
    483          
    484                  // Forward the request to the upper layer
    485                  USB_NewRequestCallback(pUsb);
    486              }
    487          
    488              // STALL sent
    489              if (ISSET(dStatus, AT91C_OTGHS_STALL)) {
    490          
    491                  TRACE_WARNING("Sta 0x%X [%d] ", dStatus, bEndpoint);
    492          
    493                  // Acknowledge STALL interrupt and disable it
    494                  pInterface->OTGHS_DEVEPTCCR[bEndpoint] = AT91C_OTGHS_STALL;
    495                  //pInterface->OTGHS_DEVEPTCDR[bEndpoint] = AT91C_OTGHS_STALL;
    496          
    497                  // If the endpoint is not halted, clear the stall condition
    498                  if (pEndpoint->dState != endpointStateHalted) {
    499          
    500                      TRACE_WARNING("_ " );
    501                      // Acknowledge the stall RQ flag
    502                      pInterface->OTGHS_DEVEPTCDR[bEndpoint] = AT91C_OTGHS_STALLRQ;
    503                  }
    504          
    505              }
    506          
    507          }
    508          
    509          
    510          //------------------------------------------------------------------------------
    511          //      Exported functions
    512          //------------------------------------------------------------------------------
    513          //------------------------------------------------------------------------------
    514          // \brief  Configure an endpoint with the provided endpoint descriptor
    515          // \param  pUsb    Pointer to a S_usb instance
    516          // \param  pEpDesc Pointer to the endpoint descriptor
    517          // \return true if the endpoint is now configured, false otherwise
    518          // \see    S_usb_endpoint_descriptor
    519          // \see    S_usb
    520          //------------------------------------------------------------------------------
    521          static bool OTGHS_ConfigureEndpoint(const S_usb *pUsb,
    522                                       const S_usb_endpoint_descriptor *pEpDesc)
    523          {
    524              AT91PS_OTGHS   pInterface = OTGHS_GetDriverInterface(pUsb);
    525              S_usb_endpoint *pEndpoint;
    526              unsigned char  bEndpoint;
    527              unsigned char  bType;
    528              unsigned char  endpointDir;
    529              unsigned short sizeEpt = 0;
    530          
    531              // Maximum packet size configuration value
    532              if( pEpDesc->wMaxPacketSize == 8 ) {
    533                  sizeEpt = AT91C_OTGHS_EPT_SIZE_8;
    534              } else if ( pEpDesc->wMaxPacketSize == 16 ) {
    535                  sizeEpt = AT91C_OTGHS_EPT_SIZE_16;
    536              } else if ( pEpDesc->wMaxPacketSize == 32 ) {
    537                  sizeEpt = AT91C_OTGHS_EPT_SIZE_32;
    538              } else if ( pEpDesc->wMaxPacketSize == 64 ) {
    539                  sizeEpt = AT91C_OTGHS_EPT_SIZE_64;
    540              } else if ( pEpDesc->wMaxPacketSize == 128 ) {
    541                  sizeEpt = AT91C_OTGHS_EPT_SIZE_128;
    542              } else if ( pEpDesc->wMaxPacketSize == 256 ) {
    543                  sizeEpt = AT91C_OTGHS_EPT_SIZE_256;
    544              } else if ( pEpDesc->wMaxPacketSize == 512 ) {
    545                  sizeEpt = AT91C_OTGHS_EPT_SIZE_512;
    546              } else if ( pEpDesc->wMaxPacketSize == 1024 ) {
    547                  sizeEpt = AT91C_OTGHS_EPT_SIZE_1024;
    548              } //else {
    549              //  sizeEpt = 0; // control endpoint
    550              //}
    551          
    552              // if pEpDesc == 0 then initialize the control endpoint
    553              if (pEpDesc == (S_usb_endpoint_descriptor const *) 0) {
    554          
    555                  bEndpoint = 0;
    556                  bType = 0;    // Control endpoint
    557              }
    558              else {
    559                  // The endpoint number
    560                  bEndpoint   = (unsigned char) (pEpDesc->bEndpointAddress & 0x7);
    561                  // Transfer type: Control, Isochronous, Bulk, Interrupt
    562                  bType = (unsigned char) (pEpDesc->bmAttributes     & 0x3);
    563                  // Direction, ignored for control endpoints
    564                  endpointDir  = (unsigned char) (pEpDesc->bEndpointAddress & (1<<7));
    565              }
    566          
    567              // Get pointer on endpoint
    568              pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
    569              if (pEndpoint == 0) {
    570          
    571                  return false;
    572              }
    573          
    574              // Configure wMaxPacketSize
    575              if (pEpDesc != 0) {
    576          
    577                  pEndpoint->wMaxPacketSize = pEpDesc->wMaxPacketSize;
    578              }
    579              else {
    580          
    581                  pEndpoint->wMaxPacketSize = USB_ENDPOINT0_MAXPACKETSIZE;
    582              }
    583          
    584              // Abort the current transfer is the endpoint was configured and in
    585              // Write or Read state
    586              if ((pEndpoint->dState == endpointStateRead)
    587                  || (pEndpoint->dState == endpointStateWrite)) {
    588          
    589                  OTGHS_EndOfTransfer(pEndpoint, USB_STATUS_RESET);
    590              }
    591          
    592              // Enter in IDLE state
    593              pEndpoint->dState = endpointStateIdle;
    594          
    595              // Reset Endpoint Fifos
    596              pInterface->OTGHS_DEVEPT |= (1<<bEndpoint<<16);
    597              pInterface->OTGHS_DEVEPT &= ~(1<<bEndpoint<<16);
    598          
    599              // Enable endpoint
    600              pInterface->OTGHS_DEVEPT |= (1<<bEndpoint);
    601          
    602              // Configure endpoint
    603              switch (bType) {
    604          
    605                  //-------------------------
    606                  case ENDPOINT_TYPE_CONTROL:
    607                  //-------------------------
    608                      TRACE_INFO("Control[%d]\n\r",bEndpoint);
    609          
    610                      //! Configure endpoint
    611                      pInterface->OTGHS_DEVEPTCFG[bEndpoint] = AT91C_OTGHS_ALLOC |
    612                                      AT91C_OTGHS_EPT_SIZE_64 | AT91C_OTGHS_EPT_DIR_OUT | AT91C_OTGHS_EPT_TYPE_CTL_EPT | AT91C_OTGHS_BK_NUMBER_1;
    613          
    614                      // Enable RXSTP interrupt
    615                      pInterface->OTGHS_DEVEPTCER[bEndpoint] = AT91C_OTGHS_RXSTP;
    616          
    617                      // Enable endpoint IT
    618                      pInterface->OTGHS_DEVIER = 1<<SHIFT_INTERUPT<<bEndpoint;
    619          
    620                      break;
    621          
    622                  //-----------------------------
    623                  case ENDPOINT_TYPE_ISOCHRONOUS:
    624                  //-----------------------------
    625                      if (endpointDir) {
    626                          TRACE_INFO("Iso In[%d]\n\r",bEndpoint);
    627          
    628                          //! Configure endpoint
    629          #ifndef DMA
    630                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] = AT91C_OTGHS_ALLOC |
    631                                                        sizeEpt | AT91C_OTGHS_EPT_DIR_IN | AT91C_OTGHS_EPT_TYPE_ISO_EPT | AT91C_OTGHS_BK_NUMBER_2;
    632          #else
    633                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] = AT91C_OTGHS_ALLOC | AT91C_OTGHS_AUTOSW |
    634                                                        sizeEpt | AT91C_OTGHS_EPT_DIR_IN | AT91C_OTGHS_EPT_TYPE_ISO_EPT | AT91C_OTGHS_BK_NUMBER_2;
    635          #endif
    636          
    637                      }
    638                      else {
    639                          TRACE_INFO("Iso Out[%d]\n\r",bEndpoint);
    640          
    641                          //! Configure endpoint
    642          #ifndef DMA
    643                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] =  AT91C_OTGHS_ALLOC |
    644                                                       sizeEpt | AT91C_OTGHS_EPT_DIR_OUT | AT91C_OTGHS_EPT_TYPE_ISO_EPT | AT91C_OTGHS_BK_NUMBER_2;
    645          #else
    646                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] = AT91C_OTGHS_ALLOC | AT91C_OTGHS_AUTOSW |
    647                                                       sizeEpt | AT91C_OTGHS_EPT_DIR_OUT | AT91C_OTGHS_EPT_TYPE_ISO_EPT | AT91C_OTGHS_BK_NUMBER_2;
    648          #endif
    649          
    650                      }
    651                      break;
    652          
    653                  //----------------------
    654                  case ENDPOINT_TYPE_BULK:
    655                  //----------------------
    656                      if (endpointDir) {
    657                          TRACE_INFO("Bulk In(%d)[%d] ",bEndpoint, pEpDesc->wMaxPacketSize);
    658                          //! Configure endpoint
    659          #ifndef DMA
    660                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] = AT91C_OTGHS_ALLOC |
    661                                                        sizeEpt | AT91C_OTGHS_EPT_DIR_IN | AT91C_OTGHS_EPT_TYPE_BUL_EPT | AT91C_OTGHS_BK_NUMBER_2;
    662          #else
    663                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] = AT91C_OTGHS_ALLOC | AT91C_OTGHS_AUTOSW |
    664                                                        sizeEpt | AT91C_OTGHS_EPT_DIR_IN | AT91C_OTGHS_EPT_TYPE_BUL_EPT | AT91C_OTGHS_BK_NUMBER_2;
    665          #endif
    666          
    667                      }
    668                      else {
    669                          TRACE_INFO("Bulk Out(%d)[%d]\n\r",bEndpoint, pEpDesc->wMaxPacketSize);
    670                          //! Configure endpoint
    671          #ifndef DMA
    672                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] =  AT91C_OTGHS_ALLOC |
    673                                                       sizeEpt | AT91C_OTGHS_EPT_DIR_OUT | AT91C_OTGHS_EPT_TYPE_BUL_EPT | AT91C_OTGHS_BK_NUMBER_2;
    674          #else
    675                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] = AT91C_OTGHS_ALLOC | AT91C_OTGHS_AUTOSW |
    676                                                       sizeEpt | AT91C_OTGHS_EPT_DIR_OUT | AT91C_OTGHS_EPT_TYPE_BUL_EPT | AT91C_OTGHS_BK_NUMBER_2;
    677          #endif
    678                      }
    679                      break;
    680          
    681                  //---------------------------
    682                  case ENDPOINT_TYPE_INTERRUPT:
    683                  //---------------------------
    684                      if (endpointDir) {
    685                          TRACE_INFO("Interrupt In[%d]\n\r",bEndpoint);
    686                          //! Configure endpoint
    687          #ifndef DMA
    688                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] = AT91C_OTGHS_ALLOC |
    689                                                        sizeEpt | AT91C_OTGHS_EPT_DIR_IN | AT91C_OTGHS_EPT_TYPE_INT_EPT | AT91C_OTGHS_BK_NUMBER_2;
    690          #else
    691                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] = AT91C_OTGHS_ALLOC | AT91C_OTGHS_AUTOSW |
    692                                                        sizeEpt | AT91C_OTGHS_EPT_DIR_IN | AT91C_OTGHS_EPT_TYPE_INT_EPT | AT91C_OTGHS_BK_NUMBER_2;
    693          #endif
    694          
    695                      }
    696                      else {
    697                          TRACE_INFO("Interrupt Out[%d]\n\r",bEndpoint);
    698                          //! Configure endpoint
    699          #ifndef DMA
    700                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] =  AT91C_OTGHS_ALLOC |
    701                                                       sizeEpt | AT91C_OTGHS_EPT_DIR_OUT | AT91C_OTGHS_EPT_TYPE_INT_EPT | AT91C_OTGHS_BK_NUMBER_2;
    702          #else
    703                          pInterface->OTGHS_DEVEPTCFG[bEndpoint] = AT91C_OTGHS_ALLOC | AT91C_OTGHS_AUTOSW |
    704                                                       sizeEpt | AT91C_OTGHS_EPT_DIR_OUT | AT91C_OTGHS_EPT_TYPE_INT_EPT | AT91C_OTGHS_BK_NUMBER_2;
    705          #endif
    706          
    707                      }
    708                      break;
    709          
    710                  //------
    711                  default:
    712                  //------
    713                      TRACE_ERROR(" unknown endpoint type\n\r");
    714                      return false;
    715              }
    716          
    717              // Check if the configuration is ok
    718              if (ISCLEARED(pInterface->OTGHS_DEVEPTCSR[bEndpoint], AT91C_OTGHS_CFGOK)) {
    719          
    720                  TRACE_FATAL("F: OTGHS_ConfigureEndpoint: Cannot configure endpoint\n\r");
    721                  return false;
    722              }
    723          
    724              return true;
    725          }
    726          
    727          
    728          //------------------------------------------------------------------------------
    729          //      Interrupt service routine
    730          //------------------------------------------------------------------------------
    731          #ifdef DMA
    732          //----------------------------------------------------------------------------
    733          //! \fn    OTGHS_DmaHandler
    734          //! \brief This function (ISR) handles DMA interrupts
    735          //----------------------------------------------------------------------------
    736          static void OTGHS_DmaHandler(const S_usb *pUsb, unsigned char endpoint)
    737          {
    738              AT91PS_OTGHS   pInterface = OTGHS_GetDriverInterface(pUsb);
    739              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, endpoint);
    740              unsigned int   csr;
    741          
    742              csr = pInterface->OTGHS_DEVDMA[endpoint].OTGHS_DEVDMASTATUS;
    743              pInterface->OTGHS_DEVIDR = (1<<SHIFT_DMA<<endpoint);
    744          
    745              if((csr & AT91C_OTGHS_END_BF_ST) || (csr & AT91C_OTGHS_END_TR_ST)) {
    746                  // READ
    747                  TRACE_DEBUG_M("END_BF_ST\n\r");
    748                  pEndpoint->dBytesTransferred = pEndpoint->dBytesBuffered;
    749                  pEndpoint->dBytesBuffered = 0;
    750          
    751                  TRACE_DEBUG_M("dBytesBuffered: 0x%x\n\r",pEndpoint->dBytesBuffered);
    752                  TRACE_DEBUG_M("dBytesRemaining: 0x%x\n\r",pEndpoint->dBytesRemaining);
    753                  TRACE_DEBUG_M("dBytesTransferred: 0x%x\n\r",pEndpoint->dBytesTransferred);
    754          
    755                  OTGHS_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
    756                  pEndpoint->dState = endpointStateIdle;
    757              }
    758              else {
    759                  TRACE_FATAL("Probleme IT DMA\n\r");
    760              }
    761          }
    762          #endif
    763          
    764          
    765          //------------------------------------------------------------------------------
    766          // \brief  OTGHS interrupt handler
    767          //
    768          //         Manages device resume, suspend, end of bus reset. Forwards endpoint
    769          //         interrupts to the appropriate handler.
    770          // \param  pUsb Pointer to a S_usb instance
    771          //------------------------------------------------------------------------------
    772          static void OTGHS_Handler(const S_usb *pUsb)
    773          {
    774              AT91PS_OTGHS  pInterface = OTGHS_GetDriverInterface(pUsb);
    775              unsigned int  dStatus;
    776              unsigned char numIT;
    777          
    778              if ( (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED))
    779                 && (ISSET(USB_GetState(pUsb), USB_STATE_POWERED))){
    780          
    781                  LED_TOGGLE(LED_USB);
    782              }
    783          
    784              TRACE_DEBUG_H("Hlr ");
    785          
    786              // Get General interrupts status
    787              dStatus = pInterface->OTGHS_SR & pInterface->OTGHS_CTRL & 0xFF;
    788              while (dStatus != 0) {
    789          
    790                  if(ISSET(dStatus, AT91C_OTGHS_VBUSTI))
    791                  {
    792                      TRACE_DEBUG_M("__VBus\n\r");
    793          
    794                      USB_Attach(pUsb);
    795          
    796                      // Acknowledge the interrupt
    797                      pInterface->OTGHS_SCR = AT91C_OTGHS_VBUSTI;
    798                  }
    799          
    800                  // Don't treat others interrupt for this time
    801                  pInterface->OTGHS_SCR = AT91C_OTGHS_IDT    | AT91C_OTGHS_SRP 
    802                                        | AT91C_OTGHS_VBERR  | AT91C_OTGHS_BCERR
    803                                        | AT91C_OTGHS_ROLEEX | AT91C_OTGHS_HNPERR
    804                                        | AT91C_OTGHS_STO;
    805          
    806                  dStatus = pInterface->OTGHS_SR & pInterface->OTGHS_CTRL & 0xFF;
    807              }
    808          
    809          
    810              // Get OTG Device interrupts status
    811              dStatus = pInterface->OTGHS_DEVISR & pInterface->OTGHS_DEVIMR;
    812              TRACE_DEBUG_H("OTGHS_DEVISR:0x%X\n\r", pInterface->OTGHS_DEVISR);
    813              while (dStatus != 0) {
    814          
    815                  // Start Of Frame (SOF)
    816                  if (ISSET(dStatus, AT91C_OTGHS_SOF)) {
    817                      TRACE_DEBUG_L("SOF ");
    818          
    819                      // Invoke the SOF callback
    820                      USB_StartOfFrameCallback(pUsb);
    821          
    822                      // Acknowledge interrupt
    823                      SET(pInterface->OTGHS_DEVICR, AT91C_OTGHS_SOF);
    824                      CLEAR(dStatus, AT91C_OTGHS_SOF);
    825                  }
    826          
    827                  // Suspend
    828                  else if (dStatus & AT91C_OTGHS_SUSP) {
    829          
    830                      TRACE_DEBUG_M("S ");
    831          
    832                      if (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED)) {
    833          
    834                          // The device enters the Suspended state
    835                          //      MCK + UDPCK must be off
    836                          //      Pull-Up must be connected
    837                          //      Transceiver must be disabled
    838          
    839                          // Enable wakeup
    840                          SET(pInterface->OTGHS_DEVIER, AT91C_OTGHS_EORST | AT91C_OTGHS_WAKEUP | AT91C_OTGHS_EORSM);
    841          
    842                          // Acknowledge interrupt
    843                          pInterface->OTGHS_DEVICR = AT91C_OTGHS_SUSP;
    844                          SET(*(pUsb->pState), USB_STATE_SUSPENDED);
    845                          OTGHS_DisableTransceiver(pUsb);
    846                          OTGHS_DisableMCK(pUsb);
    847                          OTGHS_DisableOTGHSCK(pUsb);
    848          
    849                          // Invoke the Suspend callback
    850          
    851                          USB_SuspendCallback(pUsb);
    852                      }
    853                  }
    854          
    855                  // Resume
    856                  else if (ISSET(dStatus, AT91C_OTGHS_WAKEUP)
    857                        || ISSET(dStatus, AT91C_OTGHS_EORSM)) {
    858          
    859                      // Invoke the Resume callback
    860                      USB_ResumeCallback(pUsb);
    861          
    862                      TRACE_DEBUG_M("R ");
    863          
    864                      // The device enters Configured state
    865                      //      MCK + UDPCK must be on
    866                      //      Pull-Up must be connected
    867                      //      Transceiver must be enabled
    868          
    869                      if (ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED)) {
    870          
    871                          // Powered state
    872                          OTGHS_EnableMCK(pUsb);
    873                          OTGHS_EnableOTGHSCK(pUsb);
    874          
    875                          // Default state
    876                          if (ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) {
    877          
    878                              OTGHS_EnableTransceiver(pUsb);
    879                          }
    880          
    881                          CLEAR(*(pUsb->pState), USB_STATE_SUSPENDED);
    882                      }
    883                      pInterface->OTGHS_DEVICR = 
    884                          (AT91C_OTGHS_WAKEUP | AT91C_OTGHS_EORSM | AT91C_OTGHS_SUSP);
    885          
    886                      pInterface->OTGHS_DEVIER = (AT91C_OTGHS_EORST | AT91C_OTGHS_SUSP);
    887                      pInterface->OTGHS_DEVICR = (AT91C_OTGHS_WAKEUP | AT91C_OTGHS_EORSM);
    888                      pInterface->OTGHS_DEVIDR = AT91C_OTGHS_WAKEUP;
    889          
    890                  }
    891          
    892                  // End of bus reset
    893                  else if (dStatus & AT91C_OTGHS_EORST) {
    894          
    895                      TRACE_DEBUG_M("EoB ");
    896                      // The device enters the Default state
    897                      //      MCK + UDPCK are already enabled
    898                      //      Pull-Up is already connected
    899                      //      Transceiver must be enabled
    900                      //      Endpoint 0 must be enabled
    901                      SET(*(pUsb->pState), USB_STATE_DEFAULT);
    902          
    903                      OTGHS_EnableTransceiver(pUsb);
    904          
    905                      // The device leaves the Address & Configured states
    906                      CLEAR(*(pUsb->pState), USB_STATE_ADDRESS | USB_STATE_CONFIGURED);
    907                      OTGHS_ResetEndpoints(pUsb);
    908                      OTGHS_DisableEndpoints(pUsb);
    909                      OTGHS_ConfigureEndpoint(pUsb, 0);
    910          
    911                      // Flush and enable the Suspend interrupt
    912                      SET(pInterface->OTGHS_DEVICR, AT91C_OTGHS_WAKEUP | AT91C_OTGHS_SUSP);
    913          
    914                      // Enable the Start Of Frame (SOF) interrupt if needed
    915                      if (pUsb->pCallbacks->startOfFrame != 0) {
    916          
    917                          SET(pInterface->OTGHS_DEVIER, AT91C_OTGHS_SOF);
    918                      }
    919          
    920                      // Invoke the Reset callback
    921                      USB_ResetCallback(pUsb);
    922          
    923                      // Acknowledge end of bus reset interrupt
    924                      pInterface->OTGHS_DEVICR = AT91C_OTGHS_EORST;
    925                  }
    926          
    927                  // Handle upstream resume interrupt
    928                  else if (dStatus & AT91C_OTGHS_UPRSM) {
    929          
    930                      TRACE_DEBUG_L("  External resume interrupt\n\r");
    931          
    932                      // - Acknowledge the IT
    933                      pInterface->OTGHS_DEVICR = AT91C_OTGHS_UPRSM;
    934                  }
    935          
    936                  // Endpoint interrupts
    937                  else {
    938          #ifndef DMA
    939                      // Handle endpoint interrupts
    940                      for (numIT = 0; numIT < NUM_IT_MAX; numIT++) {
    941                          if( dStatus & (1<<SHIFT_INTERUPT<<numIT) ) {
    942                              OTGHS_EndpointHandler(pUsb, numIT);
    943                          }
    944                      }
    945          #else
    946                      // Handle endpoint control interrupt
    947                      if( dStatus & (1<<SHIFT_INTERUPT<<0) ) {
    948                          OTGHS_EndpointHandler(pUsb, 0);
    949                      }
    950                      // Handle DMA interrupts
    951                      for(numIT = 1; numIT <= NUM_IT_MAX_DMA; numIT++) {
    952                          if( dStatus & (1<<SHIFT_DMA<<numIT) ) {
    953                              OTGHS_DmaHandler(pUsb, numIT);
    954                          }
    955                      }
    956          #endif
    957                  }
    958          
    959                  // Retrieve new interrupt status
    960                  dStatus = (pInterface->OTGHS_DEVISR) & (pInterface->OTGHS_DEVIMR);
    961          
    962                  // Mask unneeded interrupts
    963                  if (!ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) {
    964          
    965                      dStatus &= AT91C_OTGHS_EORST | AT91C_OTGHS_SOF;
    966                  }
    967          
    968                  TRACE_DEBUG_H("\n\r");
    969          
    970                  if (dStatus != 0) {
    971          
    972                      TRACE_DEBUG_L("  - ");
    973                  }
    974              }
    975          
    976              if ( (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED))
    977                 && (ISSET(USB_GetState(pUsb), USB_STATE_POWERED))){
    978          
    979                  LED_TOGGLE(LED_USB);
    980              }
    981          }
    982          
    983          //------------------------------------------------------------------------------
    984          // \brief  Sends data through an USB endpoint
    985          //
    986          //         Sets up the transfer descriptor, write one or two data payloads
    987          //         (depending on the number of FIFO banks for the endpoint) and then
    988          //         starts the actual transfer. The operation is complete when all
    989          //         the data has been sent.
    990          // \param  pUsb      Pointer to a S_usb instance
    991          // \param  bEndpoint Index of endpoint
    992          // \param  pData     Pointer to a buffer containing the data to send
    993          // \param  dLength   Length of the data buffer
    994          // \param  fCallback Optional function to invoke when the transfer finishes
    995          // \param  pArgument Optional argument for the callback function
    996          // \return Operation result code
    997          // \see    Operation result codes
    998          // \see    Callback_f
    999          // \see    S_usb
   1000          //------------------------------------------------------------------------------
   1001          static char OTGHS_Write(const S_usb   *pUsb,
   1002                                  unsigned char bEndpoint,
   1003                                  const void    *pData,
   1004                                  unsigned int  dLength,
   1005                                  Callback_f    fCallback,
   1006                                  void          *pArgument)
   1007          {
   1008              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   1009              AT91PS_OTGHS pInterface = OTGHS_GetDriverInterface(pUsb);
   1010          
   1011              // Check that the endpoint is in Idle state
   1012              if (pEndpoint->dState != endpointStateIdle) {
   1013          
   1014                  return USB_STATUS_LOCKED;
   1015              }
   1016          
   1017              TRACE_DEBUG_L("Write%d(%d) ", bEndpoint, dLength);
   1018          
   1019              // Setup the transfer descriptor
   1020              pEndpoint->pData = (char *) pData;
   1021              pEndpoint->dBytesRemaining = dLength;
   1022              pEndpoint->dBytesBuffered = 0;
   1023              pEndpoint->dBytesTransferred = 0;
   1024              pEndpoint->fCallback = fCallback;
   1025              pEndpoint->pArgument = pArgument;
   1026              pEndpoint->isDataSent = false;
   1027              
   1028              // Send one packet
   1029              pEndpoint->dState = endpointStateWrite;
   1030          
   1031          #ifdef DMA
   1032              // Test if endpoint type control
   1033              if (AT91C_OTGHS_EPT_TYPE_CTL_EPT == (AT91C_OTGHS_EPT_TYPE & pInterface->OTGHS_DEVEPTCFG[bEndpoint])) {
   1034          #endif
   1035                  // Enable endpoint IT
   1036                  pInterface->OTGHS_DEVIER = (1<<SHIFT_INTERUPT<<bEndpoint);
   1037                  pInterface->OTGHS_DEVEPTCER[bEndpoint] = AT91C_OTGHS_TXINI;
   1038          
   1039          #ifdef DMA
   1040              }
   1041              else {
   1042          
   1043                  // others endoint (not control)
   1044                  pEndpoint->dBytesBuffered = pEndpoint->dBytesRemaining;
   1045                  pEndpoint->dBytesRemaining = 0;
   1046          
   1047                  pInterface->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMAADDRESS = (unsigned int) pEndpoint->pData;
   1048          
   1049                  // Enable IT DMA
   1050                  pInterface->OTGHS_DEVIER = (1<<SHIFT_DMA<<bEndpoint);
   1051          
   1052                  pInterface->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMACONTROL = 
   1053                       (((pEndpoint->dBytesBuffered<<16)&AT91C_OTGHS_BUFF_LENGTH)
   1054                         | AT91C_OTGHS_END_B_EN
   1055                         | AT91C_OTGHS_END_BUFFIT
   1056                         | AT91C_OTGHS_CHANN_ENB);
   1057          
   1058              }
   1059          #endif
   1060          
   1061              return USB_STATUS_SUCCESS;
   1062          }
   1063          
   1064          //------------------------------------------------------------------------------
   1065          // \brief  Reads incoming data on an USB endpoint
   1066          //
   1067          //         This methods sets the transfer descriptor and activate the endpoint
   1068          //         interrupt. The actual transfer is then carried out by the endpoint
   1069          //         interrupt handler. The Read operation finishes either when the
   1070          //         buffer is full, or a short packet (inferior to endpoint maximum
   1071          //         packet size) is received.
   1072          // \param  pUsb      Pointer to a S_usb instance
   1073          // \param  bEndpoint Index of endpoint
   1074          // \param  pData     Pointer to a buffer to store the received data
   1075          // \param  dLength   Length of the receive buffer
   1076          // \param  fCallback Optional callback function
   1077          // \param  pArgument Optional callback argument
   1078          // \return Operation result code
   1079          // \see    Callback_f
   1080          // \see    S_usb
   1081          //------------------------------------------------------------------------------
   1082          static char OTGHS_Read(const S_usb   *pUsb,
   1083                                 unsigned char bEndpoint,
   1084                                 void          *pData,
   1085                                 unsigned int  dLength,
   1086                                 Callback_f    fCallback,
   1087                                 void          *pArgument)
   1088          {
   1089              AT91PS_OTGHS pInterface = OTGHS_GetDriverInterface(pUsb);
   1090              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   1091          
   1092              //! Return if the endpoint is not in IDLE state
   1093              if (pEndpoint->dState != endpointStateIdle) {
   1094          
   1095                  return USB_STATUS_LOCKED;
   1096              }
   1097          
   1098              TRACE_DEBUG_M("Read%d(%d) ", bEndpoint, dLength);
   1099          
   1100              // Endpoint enters Read state
   1101              pEndpoint->dState = endpointStateRead;
   1102          
   1103              //! Set the transfer descriptor
   1104              pEndpoint->pData = (char *) pData;
   1105              pEndpoint->dBytesRemaining = dLength;
   1106              pEndpoint->dBytesBuffered = 0;
   1107              pEndpoint->dBytesTransferred = 0;
   1108              pEndpoint->fCallback = fCallback;
   1109              pEndpoint->pArgument = pArgument;
   1110          
   1111          #ifdef DMA
   1112              // Test if endpoint type control
   1113              if (AT91C_OTGHS_EPT_TYPE_CTL_EPT == (AT91C_OTGHS_EPT_TYPE & pInterface->OTGHS_DEVEPTCFG[bEndpoint])) {
   1114          #endif
   1115                  // Control endpoint
   1116                  // Enable endpoint IT
   1117                  pInterface->OTGHS_DEVIER = (1<<SHIFT_INTERUPT<<bEndpoint);
   1118                  pInterface->OTGHS_DEVEPTCER[bEndpoint] = AT91C_OTGHS_RXOUT;
   1119          #ifdef DMA
   1120              }
   1121              else {
   1122          
   1123                  // others endoint (not control)
   1124                  pEndpoint->dBytesBuffered = pEndpoint->dBytesRemaining;
   1125                  pEndpoint->dBytesRemaining = 0;
   1126          
   1127                  // Enable IT DMA
   1128                  pInterface->OTGHS_DEVIER = (1<<SHIFT_DMA<<bEndpoint);
   1129          
   1130                  pInterface->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMAADDRESS = (unsigned int) pEndpoint->pData;
   1131          
   1132                  pInterface->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMACONTROL = \
   1133                                       ( (pEndpoint->dBytesBuffered<<16)
   1134                                         | AT91C_OTGHS_END_TR_EN
   1135                                         | AT91C_OTGHS_END_TR_IT
   1136                                         | AT91C_OTGHS_END_B_EN
   1137                                         | AT91C_OTGHS_END_BUFFIT
   1138                                         | AT91C_OTGHS_CHANN_ENB);
   1139              }
   1140          #endif
   1141          
   1142            return USB_STATUS_SUCCESS;
   1143          }
   1144          
   1145          //------------------------------------------------------------------------------
   1146          // \brief  Clears, sets or returns the Halt state on specified endpoint
   1147          //
   1148          //         When in Halt state, an endpoint acknowledges every received packet
   1149          //         with a STALL handshake. This continues until the endpoint is
   1150          //         manually put out of the Halt state by calling this function.
   1151          // \param  pUsb Pointer to a S_usb instance
   1152          // \param  bEndpoint Index of endpoint
   1153          // \param  bRequest  Request to perform
   1154          //                   -> USB_SET_FEATURE, USB_CLEAR_FEATURE, USB_GET_STATUS
   1155          // \return true if the endpoint is currently Halted, false otherwise
   1156          // \see    S_usb
   1157          //------------------------------------------------------------------------------
   1158          static bool OTGHS_Halt(const S_usb   *pUsb,
   1159                                 unsigned char bEndpoint,
   1160                                 unsigned char bRequest)
   1161          {
   1162              AT91PS_OTGHS pInterface = OTGHS_GetDriverInterface(pUsb);
   1163              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   1164          
   1165              // Clear the Halt feature of the endpoint if it is enabled
   1166              if (bRequest == USB_CLEAR_FEATURE) {
   1167          
   1168                  TRACE_DEBUG_L("Unhalt%d ", bEndpoint);
   1169          
   1170                  // Return endpoint to Idle state
   1171                  pEndpoint->dState = endpointStateIdle;
   1172          
   1173                  // Clear FORCESTALL flag
   1174          
   1175                  // Disable stall on endpoint
   1176                  pInterface->OTGHS_DEVEPTCDR[bEndpoint] = AT91C_OTGHS_STALLRQ;
   1177                  pEndpoint->dState = endpointStateIdle;
   1178          
   1179                  // Reset data-toggle
   1180                  pInterface->OTGHS_DEVEPTCER[bEndpoint] = AT91C_OTGHS_RSTDT;
   1181              }
   1182              // Set the Halt feature on the endpoint if it is not already enabled
   1183              // and the endpoint is not disabled
   1184              else if ((bRequest == USB_SET_FEATURE)
   1185                       && (pEndpoint->dState != endpointStateHalted)
   1186                       && (pEndpoint->dState != endpointStateDisabled)) {
   1187          
   1188                  TRACE_DEBUG_L("Halt%d ", bEndpoint);
   1189          
   1190                  // Abort the current transfer if necessary
   1191                  OTGHS_EndOfTransfer(pEndpoint, USB_STATUS_ABORTED);
   1192          
   1193                  // Put endpoint into Halt state
   1194                  pInterface->OTGHS_DEVEPTCER[bEndpoint] = AT91C_OTGHS_STALLRQ;
   1195                  pEndpoint->dState = endpointStateHalted;
   1196          
   1197                  // Enable the endpoint interrupt
   1198                  pInterface->OTGHS_DEVIER = (1<<SHIFT_INTERUPT<<bEndpoint);
   1199              }
   1200          
   1201              // Return the endpoint halt status
   1202              if (pEndpoint->dState == endpointStateHalted) {
   1203          
   1204                  return true;
   1205              }
   1206              else {
   1207          
   1208                  return false;
   1209              }
   1210          }
   1211          
   1212          //------------------------------------------------------------------------------
   1213          // \brief  Causes the endpoint to acknowledge the next received packet with
   1214          //         a STALL handshake.
   1215          //
   1216          //         Further packets are then handled normally.
   1217          // \param  pUsb      Pointer to a S_usb instance
   1218          // \param  bEndpoint Index of endpoint
   1219          // \return Operation result code
   1220          // \see    S_usb
   1221          //------------------------------------------------------------------------------
   1222          static char OTGHS_Stall(const S_usb *pUsb,
   1223                                  unsigned char bEndpoint)
   1224          {
   1225              AT91PS_OTGHS pInterface = OTGHS_GetDriverInterface(pUsb);
   1226              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   1227          
   1228              // Check that endpoint is in Idle state
   1229              if (pEndpoint->dState != endpointStateIdle) {
   1230          
   1231                  TRACE_WARNING("W: UDP_Stall: Endpoint%d locked\n\r", bEndpoint);
   1232                  return USB_STATUS_LOCKED;
   1233              }
   1234          
   1235              TRACE_DEBUG_L("Stall%d ", bEndpoint);
   1236          
   1237              pInterface->OTGHS_DEVEPTCER[bEndpoint] = AT91C_OTGHS_STALL;
   1238              pInterface->OTGHS_DEVEPTCER[bEndpoint] = AT91C_OTGHS_STALLRQ;
   1239          
   1240              return USB_STATUS_SUCCESS;
   1241          }
   1242          
   1243          //------------------------------------------------------------------------------
   1244          // \brief  Activates a remote wakeup procedure
   1245          // \param  pUsb Pointer to a S_usb instance
   1246          // \see    S_usb
   1247          //------------------------------------------------------------------------------
   1248          static void OTGHS_RemoteWakeUp(const S_usb *pUsb)
   1249          {
   1250              AT91PS_OTGHS pInterface = OTGHS_GetDriverInterface(pUsb);
   1251          
   1252              OTGHS_EnableMCK(pUsb);
   1253              OTGHS_EnableOTGHSCK(pUsb);
   1254              OTGHS_EnableTransceiver(pUsb);
   1255          
   1256              TRACE_DEBUG_L("Remote WakeUp ");
   1257          
   1258              //! Enable wakeup interrupt
   1259              //pInterface->OTGHS_DEVIER = AT91C_OTGHS_UPRSM;
   1260          
   1261              // Activates a remote wakeup
   1262              pInterface->OTGHS_DEVCTRL |= AT91C_OTGHS_RMWKUP;
   1263          }
   1264          
   1265          //------------------------------------------------------------------------------
   1266          // \brief  Handles attachment or detachment from the USB when the VBus power
   1267          //         line status changes.
   1268          // \param  pUsb Pointer to a S_usb instance
   1269          // \return true if VBus is present, false otherwise
   1270          // \see    S_usb
   1271          //------------------------------------------------------------------------------
   1272          static bool OTGHS_Attach(const S_usb *pUsb)
   1273          {
   1274              AT91PS_OTGHS pInterface = OTGHS_GetDriverInterface(pUsb);
   1275          
   1276              TRACE_DEBUG_L("Attach(");
   1277          
   1278              // Check if VBus is present
   1279              if (!ISSET(USB_GetState(pUsb), USB_STATE_POWERED)
   1280                  && BRD_IsVBusConnected(pInterface)) {
   1281          
   1282                  // Powered state:
   1283                  //      MCK + UDPCK must be on
   1284                  //      Pull-Up must be connected
   1285                  //      Transceiver must be disabled
   1286          
   1287                  // Invoke the Resume callback
   1288                  USB_ResumeCallback(pUsb);
   1289          
   1290                  OTGHS_EnableMCK(pUsb);
   1291                  OTGHS_EnableOTGHSCK(pUsb);
   1292          
   1293                  // Enable the transceiver
   1294                  OTGHS_EnableTransceiver(pUsb);
   1295          
   1296                  // Reconnect the pull-up if needed
   1297                  if (ISSET(*(pUsb->pState), USB_STATE_SHOULD_RECONNECT)) {
   1298          
   1299                      USB_Connect(pUsb);
   1300                      CLEAR(*(pUsb->pState), USB_STATE_SHOULD_RECONNECT);
   1301                  }
   1302          
   1303                  // Clear the Suspend and Resume interrupts
   1304                  pInterface->OTGHS_DEVICR = \
   1305                       AT91C_OTGHS_WAKEUP | AT91C_OTGHS_EORSM | AT91C_OTGHS_SUSP;
   1306          
   1307                  // Enable interrupt
   1308                  pInterface->OTGHS_DEVIER = AT91C_OTGHS_EORST | AT91C_OTGHS_WAKEUP | AT91C_OTGHS_EORSM;
   1309              
   1310                  // The device is in Powered state
   1311                  SET(*(pUsb->pState), USB_STATE_POWERED);
   1312          
   1313              }
   1314              else if (ISSET(USB_GetState(pUsb), USB_STATE_POWERED)
   1315                       && !BRD_IsVBusConnected(pInterface)) {
   1316          
   1317                  // Attached state:
   1318                  //      MCK + UDPCK off
   1319                  //      Pull-Up must be disconnected
   1320                  //      Transceiver must be disabled
   1321          
   1322                  // Warning: MCK must be enabled to be able to write in UDP registers
   1323                  // It may have been disabled by the Suspend interrupt, so re-enable it
   1324                  OTGHS_EnableMCK(pUsb);
   1325          
   1326                  // Disable interrupts
   1327                  pInterface->OTGHS_DEVIDR &= ~(AT91C_OTGHS_WAKEUP | AT91C_OTGHS_EORSM
   1328                                              | AT91C_OTGHS_SUSP   | AT91C_OTGHS_SOF);
   1329          
   1330                  OTGHS_DisableEndpoints(pUsb);
   1331          
   1332                  // Disconnect the pull-up if needed
   1333                  if (ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) {
   1334          
   1335                      USB_Disconnect(pUsb);
   1336                      SET(*(pUsb->pState), USB_STATE_SHOULD_RECONNECT);
   1337                  }
   1338          
   1339                  OTGHS_DisableTransceiver(pUsb);
   1340                  OTGHS_DisableMCK(pUsb);
   1341                  OTGHS_DisableOTGHSCK(pUsb);
   1342          
   1343                  // The device leaves the all states except Attached
   1344                  CLEAR(*(pUsb->pState), USB_STATE_POWERED | USB_STATE_DEFAULT
   1345                        | USB_STATE_ADDRESS | USB_STATE_CONFIGURED | USB_STATE_SUSPENDED);
   1346          
   1347                  // Invoke the Suspend callback
   1348                  USB_SuspendCallback(pUsb);
   1349          
   1350              }
   1351          
   1352              TRACE_DEBUG_L("%d) ", ISSET(USB_GetState(pUsb), USB_STATE_POWERED));
   1353          
   1354              return ISSET(USB_GetState(pUsb), USB_STATE_POWERED);
   1355          }
   1356          
   1357          //------------------------------------------------------------------------------
   1358          // \brief  Sets the device address
   1359          //
   1360          //         This function directly accesses the S_usb_request instance located
   1361          //         in the S_usb structure to extract its new address.
   1362          // \param  pUsb Pointer to a S_usb instance
   1363          // \see    S_usb
   1364          //------------------------------------------------------------------------------
   1365          static void OTGHS_SetAddress(S_usb const *pUsb)
   1366          {
   1367              unsigned short wAddress = USB_GetSetup(pUsb)->wValue;
   1368              AT91PS_OTGHS pInterface = OTGHS_GetDriverInterface(pUsb);
   1369          
   1370              TRACE_DEBUG_L("SetAddr(%d) ", wAddress);
   1371          
   1372              // Set address
   1373              pInterface->OTGHS_DEVCTRL = wAddress & AT91C_OTGHS_UADD;
   1374              pInterface->OTGHS_DEVCTRL |= AT91C_OTGHS_ADDEN;
   1375          
   1376          }
   1377          
   1378          //------------------------------------------------------------------------------
   1379          // \brief  Changes the device state from Address to Configured, or from
   1380          //         Configured to Address.
   1381          //
   1382          //         This method directly access the last received SETUP packet to
   1383          //         decide on what to do.
   1384          // \see    S_usb
   1385          //------------------------------------------------------------------------------
   1386          static void OTGHS_SetConfiguration(S_usb const *pUsb)
   1387          {
   1388              unsigned short wValue = USB_GetSetup(pUsb)->wValue;
   1389          
   1390              TRACE_DEBUG_L("SetCfg() ");
   1391          
   1392              // Check the request
   1393              if (wValue != 0) {
   1394                  // Enter Configured state
   1395                  SET(*(pUsb->pState), USB_STATE_CONFIGURED);
   1396          
   1397              }
   1398              else {
   1399          
   1400                  // Go back to Address state
   1401                  CLEAR(*(pUsb->pState), USB_STATE_CONFIGURED);
   1402          
   1403                  // Abort all transfers
   1404                  OTGHS_DisableEndpoints(pUsb);
   1405              }
   1406          }
   1407          
   1408          //------------------------------------------------------------------------------
   1409          // \brief  Enables the pull-up on the D+ line to connect the device to the USB.
   1410          // \param  pUsb Pointer to a S_usb instance
   1411          // \see    S_usb
   1412          //------------------------------------------------------------------------------
   1413          static void OTGHS_Connect(const S_usb *pUsb)
   1414          {
   1415          #if defined(INTERNAL_PULLUP)
   1416              CLEAR(OTGHS_GetDriverInterface(pUsb)->OTGHS_DEVCTRL, AT91C_OTGHS_DETACH);
   1417          
   1418          #elif defined(INTERNAL_PULLUP_MATRIX)
   1419              TRACE_DEBUG_L("PUON 1\n\r");
   1420              AT91C_BASE_MATRIX->MATRIX_USBPCR |= AT91C_MATRIX_USBPCR_PUON;
   1421          
   1422          #else
   1423              BRD_ConnectPullUp(UDP_GetDriverInterface(pUsb));
   1424          
   1425          #endif
   1426          }
   1427          
   1428          //------------------------------------------------------------------------------
   1429          // \brief  Disables the pull-up on the D+ line to disconnect the device from
   1430          //         the bus.
   1431          // \param  pUsb Pointer to a S_usb instance
   1432          // \see    S_usb
   1433          //------------------------------------------------------------------------------
   1434          static void OTGHS_Disconnect(const S_usb *pUsb)
   1435          {
   1436          #if defined(INTERNAL_PULLUP)
   1437              SET(OTGHS_GetDriverInterface(pUsb)->OTGHS_DEVCTRL, AT91C_OTGHS_DETACH);
   1438          
   1439          #elif defined(INTERNAL_PULLUP_MATRIX)
   1440              TRACE_DEBUG_L("PUON 0\n\r");
   1441              AT91C_BASE_MATRIX->MATRIX_USBPCR &= ~AT91C_MATRIX_USBPCR_PUON;
   1442          
   1443          #else
   1444              BRD_DisconnectPullUp(UDP_GetDriverInterface(pUsb));
   1445          
   1446          #endif
   1447              // Device leaves the Default state
   1448              CLEAR(*(pUsb->pState), USB_STATE_DEFAULT);
   1449          }
   1450          
   1451          //------------------------------------------------------------------------------
   1452          // \brief  Certification test for High Speed device.
   1453          // \param  pUsb Pointer to a S_usb instance
   1454          // \param  bIndex char for the test choice
   1455          // \see    S_usb
   1456          //------------------------------------------------------------------------------
   1457          static void OTGHS_Test(const S_usb *pUsb, unsigned char bIndex)
   1458          {
   1459              AT91PS_OTGHS pInterface = OTGHS_GetDriverInterface(pUsb);
   1460          
   1461              pInterface->OTGHS_DEVIDR &= ~AT91C_OTGHS_SUSP;
   1462              pInterface->OTGHS_DEVCTRL |= AT91C_OTGHS_SPDCONF_HS; // remove suspend ?
   1463          
   1464              switch( bIndex ) {
   1465                  case TEST_PACKET:
   1466                      TRACE_DEBUG_M("TEST_PACKET ");
   1467                      pInterface->OTGHS_DEVCTRL |= AT91C_OTGHS_TSTPCKT;
   1468                      break;
   1469          
   1470                  case TEST_J:
   1471                      TRACE_DEBUG_M("TEST_J ");
   1472                      pInterface->OTGHS_DEVCTRL |= AT91C_OTGHS_TSTJ;
   1473                      break;
   1474          
   1475                  case TEST_K:
   1476                      TRACE_DEBUG_M("TEST_K ");
   1477                      pInterface->OTGHS_DEVCTRL |= AT91C_OTGHS_TSTK;
   1478                      break;
   1479          
   1480                  case TEST_SEO_NAK:
   1481                      TRACE_DEBUG_M("TEST_SEO_NAK ");
   1482                      pInterface->OTGHS_DEVIDR = 0xFFFFFFFF;
   1483                      break;
   1484          
   1485                  case TEST_SEND_ZLP:
   1486                      pInterface->OTGHS_DEVEPTCCR[0] = AT91C_OTGHS_TXINI;
   1487                      TRACE_DEBUG_M("SEND_ZLP ");
   1488                      break;
   1489          
   1490                  TRACE_DEBUG_M("\n\r");
   1491              }
   1492          }
   1493          
   1494          //------------------------------------------------------------------------------
   1495          // \brief  Certification test for High Speed device.
   1496          // \param  pUsb Pointer to a S_usb instance
   1497          // \see    S_usb
   1498          //------------------------------------------------------------------------------
   1499          static bool OTGHS_IsHighSpeed(const S_usb *pUsb)
   1500          {
   1501              AT91PS_OTGHS pInterface = OTGHS_GetDriverInterface(pUsb);
   1502              bool         status = false;
   1503          
   1504              if(AT91C_OTGHS_SPEED_SR_HS == (pInterface->OTGHS_SR & (0x03<<12))) {
   1505                  // High Speed
   1506                  status = true;
   1507              }
   1508          
   1509              return status;
   1510          }
   1511          
   1512          //------------------------------------------------------------------------------
   1513          // \brief  Initializes the specified USB driver
   1514          //
   1515          //         This function initializes the current FIFO bank of endpoints,
   1516          //         configures the pull-up and VBus lines, disconnects the pull-up and
   1517          //         then trigger the Init callback.
   1518          // \param  pUsb Pointer to a S_usb instance
   1519          // \see    S_usb
   1520          //------------------------------------------------------------------------------
   1521          static void OTGHS_Init(const S_usb *pUsb)
   1522          {
   1523              AT91PS_OTGHS  pInterface = OTGHS_GetDriverInterface(pUsb);
   1524              unsigned char i;
   1525          
   1526              TRACE_DEBUG_L("Init()\n\r");
   1527          
   1528              // Enable USB macro
   1529              SET(OTGHS_GetDriverInterface(pUsb)->OTGHS_CTRL, AT91C_OTGHS_USBECTRL);
   1530          
   1531              pInterface->OTGHS_DEVCTRL &=~ AT91C_OTGHS_DETACH; // detach
   1532          
   1533              //// Force FS (for debug or test)
   1534          //    pDriver->OTGHS_DEVCTRL |= AT91C_OTGHS_SPDCONF_FS;
   1535              pInterface->OTGHS_DEVCTRL &= ~AT91C_OTGHS_SPDCONF_FS;   // Normal mode
   1536              pInterface->OTGHS_DEVCTRL &= ~(  AT91C_OTGHS_LS | AT91C_OTGHS_TSTJ
   1537                                          | AT91C_OTGHS_TSTK | AT91C_OTGHS_TSTPCKT
   1538                                          | AT91C_OTGHS_OPMODE2 ); // Normal mode
   1539          
   1540          
   1541              // With OR without DMA !!!
   1542              // Initialization of DMA
   1543              for( i=1; i<=((AT91C_BASE_OTGHS->OTGHS_IPFEATURES & AT91C_OTGHS_DMA_CHANNEL_NBR)>>4); i++ ) {
   1544          
   1545                  // RESET endpoint canal DMA:
   1546                  // DMA stop channel command
   1547                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[i].OTGHS_DEVDMACONTROL = 0;  // STOP command
   1548          
   1549                  // Disable endpoint
   1550                  AT91C_BASE_OTGHS->OTGHS_DEVEPTCDR[i] = 0XFFFFFFFF;
   1551          
   1552                  // Reset endpoint config
   1553                  AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[i] = 0;
   1554          
   1555                  // Reset DMA channel (Buff count and Control field)
   1556                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[i].OTGHS_DEVDMACONTROL = 0x02;  // NON STOP command
   1557          
   1558                  // Reset DMA channel 0 (STOP)
   1559                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[i].OTGHS_DEVDMACONTROL = 0;  // STOP command
   1560          
   1561                  // Clear DMA channel status (read the register for clear it)
   1562                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[i].OTGHS_DEVDMASTATUS = AT91C_BASE_OTGHS->OTGHS_DEVDMA[i].OTGHS_DEVDMASTATUS;
   1563          
   1564              }
   1565          
   1566              // Enable clock OTG pad
   1567              pInterface->OTGHS_CTRL &= ~AT91C_OTGHS_FRZCLKCTRL;
   1568          
   1569              // Clear General IT
   1570              pInterface->OTGHS_SCR = 0x01FF;
   1571          
   1572              // Clear OTG Device IT
   1573              pInterface->OTGHS_DEVICR = 0xFF;
   1574          
   1575              // Clear OTG Host IT
   1576              pInterface->OTGHS_HSTICR = 0x7F;
   1577          
   1578              // Reset all Endpoints Fifos
   1579              pInterface->OTGHS_DEVEPT |= (0x7F<<16);
   1580              pInterface->OTGHS_DEVEPT &= ~(0x7F<<16);
   1581          
   1582              // Disable all endpoints
   1583              pInterface->OTGHS_DEVEPT &= ~0x7F;
   1584          
   1585              // Bypass UTMI problems // jcb to be removed with new version of UTMI
   1586              // pInterface->OTGHS_TSTA2 = (1<<6)|(1<<7)|(1<<8);
   1587              // pInterface->OTGHS_TSTA2 = (1<<8);
   1588              pInterface->OTGHS_TSTA2 = 0;
   1589          
   1590              // External pull-up on D+
   1591              // Configure
   1592              BRD_ConfigurePullUp(pInterface);
   1593          
   1594              // Detach
   1595              OTGHS_Disconnect(pUsb);
   1596          
   1597              // Device is in the Attached state
   1598              *(pUsb->pState) = USB_STATE_ATTACHED;
   1599          
   1600              // Disable the UDP transceiver and interrupts
   1601              OTGHS_EnableMCK(pUsb);
   1602              SET(pInterface->OTGHS_DEVIER, AT91C_OTGHS_EORSM);
   1603          
   1604              OTGHS_DisableMCK(pUsb);
   1605              OTGHS_Disconnect(pUsb);
   1606          
   1607              // Test ID
   1608              if( 0 != (pInterface->OTGHS_SR & AT91C_OTGHS_ID) ) {
   1609                  TRACE_INFO("ID=1: PERIPHERAL\n\r");
   1610              }
   1611              else {
   1612                  TRACE_INFO("ID=0: HOST\n\r");
   1613              }
   1614          
   1615              // Test VBUS
   1616              if( 0 != (pInterface->OTGHS_SR & AT91C_OTGHS_VBUSSR) ) {
   1617                  TRACE_INFO("VBUS = 1\n\r");
   1618              }
   1619              else {
   1620                  TRACE_INFO("VBUS = 0\n\r");
   1621              }
   1622          
   1623              // Test SPEED
   1624              if(AT91C_OTGHS_SPEED_SR_HS == (pInterface->OTGHS_SR & (0x03<<12))) {
   1625                  TRACE_INFO("HIGH SPEED\n\r");
   1626              }
   1627              else if(AT91C_OTGHS_SPEED_SR_LS == (pInterface->OTGHS_SR & (0x03<<12))) {
   1628                  TRACE_INFO("LOW SPEED\n\r");
   1629              }
   1630              else {
   1631                  TRACE_INFO("FULL SPEED\n\r");
   1632              }
   1633          
   1634              // Configure interrupts
   1635              USB_InitCallback(pUsb);
   1636          
   1637              pInterface->OTGHS_CTRL |= AT91C_OTGHS_VBUSTI;
   1638          }
   1639          
   1640          //------------------------------------------------------------------------------
   1641          //      Global variables
   1642          //------------------------------------------------------------------------------
   1643          
   1644          // \brief Low-level driver methods to use with the OTGHS USB controller
   1645          // \see S_driver_methods
   1646          const S_driver_methods sOTGHSMethods = {
   1647          
   1648              OTGHS_Init,
   1649              OTGHS_Write,
   1650              OTGHS_Read,
   1651              OTGHS_Stall,
   1652              OTGHS_Halt,
   1653              OTGHS_RemoteWakeUp,
   1654              OTGHS_ConfigureEndpoint,
   1655              OTGHS_Attach,
   1656              OTGHS_SetAddress,
   1657              OTGHS_SetConfiguration,
   1658              OTGHS_Handler,
   1659              OTGHS_Connect,
   1660              OTGHS_Disconnect,
   1661              OTGHS_Test,
   1662              OTGHS_IsHighSpeed
   1663          };
   1664          
   1665          // \brief  Default driver when an UDP controller is present on a chip
   1666          const S_usb_driver sDefaultDriver = {
   1667          
   1668              AT91C_BASE_OTGHS,
   1669              AT91C_BASE_OTGHS_EPTFIFO,
   1670              0,
   1671              AT91C_ID_OTGHS,
   1672              AT91C_PMC_OTG,
   1673              &sOTGHSMethods
   1674          };
   1675          
   1676          #endif //#ifdef CHIP_OTGHS
   1677          


 
 
 0 bytes of memory

Errors: none
Warnings: none
